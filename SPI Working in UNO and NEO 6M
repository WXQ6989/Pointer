#include "SPI.h" // necessary library
#define I2C_ADDRESS 0x3C
#include "SSD1306Ascii.h"
#include "SSD1306AsciiAvrI2c.h"
SSD1306AsciiAvrI2c oled;
#define DATAOUT 11//MOSI
#define DATAIN  12//MISO
#define SPICLOCK  13//sck
#define SLAVESELECT 10//ss

#include <NMEAGPS.h>
#include <GPSport.h>
NMEAGPS  gps; // This parses the GPS characters
gps_fix  fix; // This holds on to the latest values
int Year = 2020;                            // Date (Year)
int Month = 10;                             // Date (Month)
int Day  = 10;                              // Date (Day) 
int timeHH=12;                              // Time (Hours)
int timeMM=00;                              // Time (Minutes)
int timeSS=0;                               // Time (Seconds)
float Latitude=48.5216;                     // Latitude (signed degrees)
float Longitude=9.0576;                     // Longitude (signed degrees)
int32_t  no_satellites;                     // Number of satellites
#define pi 3.14159265
#define rad2deg(X) ((X)/pi*180)
#define deg2rad(X) ((X)/180*pi)
double Timenow;



#define HIGH 0
#define LOW 1
byte clr;
//data buffer
char buffer [128];
byte output_data;

void fill_buffer()
{
  for (int I=0;I<128;I++)
  {
    buffer[I]=I;
  }
}

char spi_transfer(volatile char data)
{
  SPDR = data;                    // Start the transmission
  while (!(SPSR & (1<<SPIF)))     // Wait the end of the transmission
  {
  };
  return SPDR;                    // return the received byte
}

void setup()
{
  Serial.begin(9600);

  pinMode(DATAOUT, OUTPUT);
  pinMode(DATAIN, INPUT);
  pinMode(SPICLOCK,OUTPUT);
  pinMode(SLAVESELECT,OUTPUT);
  digitalWrite(SLAVESELECT,HIGH); //disable device
  // SPCR = 01010000
  //interrupt disabled,spi enabled,msb 1st,master,clk low when idle,
  //sample on leading edge of clk,system clock/4 rate (fastest)
  SPCR = (1<<SPE)|(1<<MSTR)| (1<<SPR1) | (1<<SPR0);
  clr=SPSR;
  clr=SPDR;
  oled.begin(&Adafruit128x64, I2C_ADDRESS);
  oled.setFont(System5x7);
  oled.clear();
}

byte read()
{
  int data;
  digitalWrite(SLAVESELECT,LOW);
  data = spi_transfer(0x00); //get data byte
  digitalWrite(SLAVESELECT,HIGH); //release chip, signal end transfer
  return data;
}

void loop()
{
  output_data = read();
  fix = gps.read();
  if ((int)output_data != 255) //sometimes 255 values come in the output
    Serial.print((char)output_data);
  delay(100); //pause for readability
}
void update_gps() {
  if (fix.valid.time) {
      Year = fix.dateTime.year,
      Month = fix.dateTime.month,
      Day = fix.dateTime.date,
      timeHH = fix.dateTime.hours;
      timeMM = fix.dateTime.minutes;
      timeSS = fix.dateTime.seconds;
      Timenow = ((double)timeHH + ((((double)timeSS / 60.0) + (double)timeMM) / 60.0));
    }   
    if (fix.valid.location) {
      Latitude = fix.latitudeL()/10000000.0;
      Longitude = fix.longitudeL()/10000000.0;
    }
    no_satellites = fix.satellites;
     //Serial.println(no_satellites); 
    oled.setCursor(0, 1); 
    oled.print("Lat:"); 
    oled.println(fix.latitudeL()/10000000.0, 6);
    oled.setCursor(0, 2); 
    oled.print("Lon:");
    oled.print(fix.longitudeL()/10000000.0,6);
    oled.setCursor(88, 2);
    oled.print("Sat#:"); 
    oled.println(fix.satellites, 6);
    oled.setCursor(0, 3); 
    oled.print("Date:"); printDate();
    oled.setCursor(0, 4); 
    oled.print("Time:"); printTime(); 
}
void printDate(){
  oled.print(fix.dateTime.date);
  oled.print("/");
  oled.print(fix.dateTime.month);
  oled.print("/");
  oled.println(fix.dateTime.year);
}
void printTime(){
  oled.print(fix.dateTime.hours);
  oled.print(":");
  if (fix.dateTime.minutes < 10) oled.print('0');
  oled.print(fix.dateTime.minutes);
  oled.print(":");
  if (fix.dateTime.seconds < 10) oled.print('0');
  oled.println(fix.dateTime.seconds);
}
